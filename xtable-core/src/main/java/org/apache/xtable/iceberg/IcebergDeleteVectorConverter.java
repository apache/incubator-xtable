/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 
package org.apache.xtable.iceberg;

import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.UUID;

import lombok.Builder;
import lombok.extern.log4j.Log4j2;

import org.apache.iceberg.DeleteFile;
import org.apache.iceberg.PartitionSpec;
import org.apache.iceberg.data.Record;
import org.apache.iceberg.data.parquet.GenericParquetWriter;
import org.apache.iceberg.deletes.PositionDelete;
import org.apache.iceberg.deletes.PositionDeleteWriter;
import org.apache.iceberg.io.FileIO;
import org.apache.iceberg.io.OutputFile;
import org.apache.iceberg.parquet.Parquet;

import org.apache.xtable.model.storage.InternalDeletionVector;

@Log4j2
@Builder(builderClassName = "Builder")
public class IcebergDeleteVectorConverter {
  // Path to the directory where the delete files generated by this converter are stored
  private String directoryPath;

  public static class Builder {
    public Builder directoryPath(Path directoryPath) {
      return directoryPath(directoryPath.toString());
    }

    public Builder directoryPath(String directoryPath) {
      this.directoryPath = directoryPath;
      return this;
    }
  }

  /**
   * Converts (@link InternalDeletionVector internal representation of positional deletes) to
   * Iceberg positional delete representation and writes to a position delete file. The method
   * generates a new position delete file using parquet format using delete-UUID.parquet name
   * pattern in the given directory
   *
   * @return metadata, {@link DeleteFile}, of the generated file
   */
  public DeleteFile toIceberg(FileIO fileIO, InternalDeletionVector vector) throws IOException {
    // generate a name for a new positional delete file
    String posDeleteFileName = "delete-" + UUID.randomUUID() + ".parquet";
    String posDeleteFilePath = Paths.get(directoryPath, posDeleteFileName).toString();
    String dataFilePath = vector.dataFilePath();
    log.info("Creating a new positional delete file: {} for {}", posDeleteFilePath, dataFilePath);
    OutputFile out = fileIO.newOutputFile(posDeleteFilePath);

    PositionDeleteWriter<Record> deleteWriter =
        Parquet.writeDeletes(out)
            .createWriterFunc(GenericParquetWriter::buildWriter)
            // .rowSchema(tableSchema)
            // TODO add support for partitioned tables
            .withSpec(PartitionSpec.unpartitioned())
            .buildPositionWriter();
    PositionDelete<Record> positionDelete = PositionDelete.create();
    try (PositionDeleteWriter<Record> writer = deleteWriter) {
      vector
          .ordinalsIterator()
          .forEachRemaining(
              ordinal -> writer.write(positionDelete.set(dataFilePath, ordinal, null)));
    }

    // TODO optimize files by partitions
    DeleteFile posDeleteFile = deleteWriter.toDeleteFile();
    log.info("Created a new positional delete file: {}", posDeleteFilePath);
    return posDeleteFile;
  }
}
